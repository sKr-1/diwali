<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Happy Diwali â€” Fireworks!</title>
  <link rel="stylesheet" href="styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;600&display=swap" rel="stylesheet">
</head>
<body>
  <div class="page">
    <header class="hero">
      <h1>Happy Diwali!</h1>
      <p class="subtitle">Light, color, and loud crackers â€” enjoy the show ðŸŽ†</p>
      <div class="controls">
        <label>
          <input id="soundToggle" type="checkbox" checked>
          Sound
        </label>
        <label>
          Firework intensity
          <input id="intensity" type="range" min="1" max="6" value="3">
        </label>
        <button id="clearBtn">Clear Sparks</button>
      </div>
    </header>

    <canvas id="fxCanvas"></canvas>

    <footer class="footer">
      <small>Made with âœ¨ for Diwali</small>
      <small>â€” Click / Tap anywhere to launch a rocket â€”</small>
    </footer>
  </div>

  <script>
  // Fireworks & Cracker Simulation
  // Author: ChatGPT (example)
  (() => {
    const canvas = document.getElementById('fxCanvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let W = 0, H = 0, ratio = 1;
    const rockets = [];
    const particles = [];
    const crackers = [];
    const maxRocketsBase = 3;
    const colors = [
      '#ff3b3b', '#ffb86b', '#ffd56b', '#fff56b',
      '#8bff7a', '#7afff0', '#7ab6ff', '#b07aff', '#ff7adf'
    ];

    // Audio (simple pop/crackle)
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioContext ? new AudioContext() : null;

    function resize() {
      ratio = window.devicePixelRatio || 1;
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = Math.round(W * ratio);
      canvas.height = Math.round(H * ratio);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // Utility
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
    function choose(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    // Rocket class
    class Rocket {
      constructor(x, targetX, targetY, color) {
        this.x = x;
        this.y = H + rand(10, 80);
        this.vx = (targetX - x) / rand(50, 110);
        this.vy = -rand(6, 12);
        this.ax = 0;
        this.ay = 0.12; // gravity slightly upward to slow after engine cuts
        this.targetY = targetY;
        this.exploded = false;
        this.color = color || choose(colors);
        this.trail = [];
        this.size = rand(2, 3);
      }
      update(i) {
        this.vx += this.ax;
        this.vy += this.ay;
        this.x += this.vx;
        this.y += this.vy;
        // trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 8) this.trail.shift();

        // explode condition: near target y or vy > -1 (slowing) or random
        if (!this.exploded && (this.y <= this.targetY || this.vy > -1 || Math.random() < 0.002)) {
          this.explode();
          rockets.splice(i, 1);
        }
      }
      explode() {
        this.exploded = true;
        const count = randInt(20, 70);
        const hue = this.color;
        // generate particles
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 5 + 1;
          const p = new Particle(this.x, this.y, Math.cos(angle) * speed, Math.sin(angle) * speed, choose(colors), rand(1.2, 3.5));
          particles.push(p);
        }
        // occasional ring effect
        if (Math.random() < 0.25) {
          const ringCount = randInt(10, 20);
          for (let i = 0; i < ringCount; i++) {
            const a = (i / ringCount) * Math.PI * 2;
            const s = 3 + Math.random() * 3;
            particles.push(new Particle(this.x, this.y, Math.cos(a) * s, Math.sin(a) * s, choose(colors), rand(1.5, 2.8)));
          }
        }

        if (soundOn()) boomSound(this.x / W, 1.2 + Math.random() * 1.6);
      }
      draw() {
        // draw body
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 12;
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        // trail
        for (let i = 0; i < this.trail.length; i++) {
          const t = this.trail[i];
          const a = (i / this.trail.length) * 0.6;
          ctx.beginPath();
          ctx.fillStyle = hexWithAlpha(this.color, 0.25 * a + 0.05);
          ctx.arc(t.x, t.y, (this.size / 1.6) * (1 - i / this.trail.length) + 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    // Particle class for explosion
    class Particle {
      constructor(x, y, vx, vy, color, size) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.color = color;
        this.size = size;
        this.life = randInt(40, 100);
        this.age = 0;
        this.gravity = 0.04 + Math.random() * 0.06;
        this.fade = 0.015 + Math.random() * 0.02;
        this.spin = Math.random() * 0.2 - 0.1;
      }
      update(i) {
        this.vx *= 0.995;
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.age++;
        // sparks can spawn mini-embers (crackle)
        if (Math.random() < 0.006 && this.age < this.life * 0.6) {
          if (soundOn()) smallPop(this.x / W);
          particles.push(new Ember(this.x, this.y, rand(-1.2,1.2), rand(-1.2,1.2), this.color));
        }
        if (this.age >= this.life) particles.splice(i, 1);
      }
      draw() {
        const a = Math.max(0, 1 - (this.age / this.life));
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = hexWithAlpha(this.color, a);
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10 * a;
        ctx.arc(this.x, this.y, this.size * a, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // Ember for little crackle bits
    class Ember {
      constructor(x, y, vx, vy, color) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.color = color;
        this.size = rand(0.6, 1.6);
        this.life = randInt(12, 28);
        this.age = 0;
      }
      update(i) {
        this.vy += 0.06;
        this.vx *= 0.99;
        this.x += this.vx;
        this.y += this.vy;
        this.age++;
        if (this.age >= this.life) particles.splice(i, 1);
      }
      draw() {
        const a = 1 - (this.age / this.life);
        ctx.beginPath();
        ctx.fillStyle = hexWithAlpha(this.color, 0.9 * a);
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Cracker (ground-level short pop)
    class Cracker {
      constructor(x, color) {
        this.x = x;
        this.y = H - rand(20, 60);
        this.color = color || choose(colors);
        this.age = 0;
        this.life = randInt(20, 40);
        this.pieces = randInt(6, 20);
        this.spawn();
      }
      spawn() {
        for (let i = 0; i < this.pieces; i++) {
          const a = Math.random() * Math.PI - Math.PI/2;
          const s = Math.random() * 4 + 1;
          particles.push(new Particle(this.x, this.y, Math.cos(a) * s, Math.sin(a) * s - 1, this.color, rand(0.8,2.2)));
        }
        if (soundOn()) crackerSound(this.x / W);
      }
      update(i) {
        this.age++;
        if (this.age > this.life) crackers.splice(i, 1);
      }
      draw() {}
    }

    // Helpers
    function hexWithAlpha(hex, alpha) {
      // Accepts #rrggbb and returns rgba string
      const c = hex.replace('#','');
      const r = parseInt(c.substring(0,2),16);
      const g = parseInt(c.substring(2,4),16);
      const b = parseInt(c.substring(4,6),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // Sound helpers (basic explosion + pop using Web Audio)
    function soundOn() {
      return document.getElementById('soundToggle').checked && audioCtx;
    }
    function boomSound(pan = 0.5, freq = 2.0) {
      if (!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const panNode = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;
      o.type = 'sine';
      o.frequency.value = 60 * freq;
      g.gain.value = 0;
      // low rumble
      o.connect(g);
      if (panNode) g.connect(panNode), panNode.connect(audioCtx.destination);
      else g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.6, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, now + 1.4);
      o.frequency.exponentialRampToValueAtTime(30, now + 1.2);
      if (panNode) panNode.pan.setValueAtTime(pan * 2 - 1, now);
      o.start(now);
      o.stop(now + 1.5);
    }
    function smallPop(pan = 0.5) {
      if (!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'triangle';
      o.frequency.value = rand(600, 1200);
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.15, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.09);
      o.start(now);
      o.stop(now + 0.12);
    }
    function crackerSound(pan = 0.5) {
      if (!audioCtx) return;
      // multiple quick pops + high hiss
      for (let i = 0; i < 3; i++) {
        setTimeout(() => smallPop(pan), i * 40);
      }
    }

    // Launch logic
    function launchRocket(x = rand(60, W - 60), targetX = null, intensity = 1) {
      const tx = targetX || rand(60, W - 60);
      const ty = rand(H * 0.12, H * 0.45);
      rockets.push(new Rocket(x, tx, ty, choose(colors)));
    }

    // Auto spawner
    let autoTimer = 0;
    function spawnAuto(intensity) {
      const spawnRate = Math.max(0.5, 2.8 - intensity); // lower = more frequent
      if (autoTimer <= 0) {
        // sometimes crackers on ground
        if (Math.random() < 0.25) {
          crackers.push(new Cracker(rand(40, W - 40)));
        }
        // spawn multiple rockets per auto cycle
        for (let i = 0; i < Math.max(1, intensity); i++) {
          const x = Math.random() < 0.5 ? rand(40, W / 2) : rand(W / 2, W - 40);
          launchRocket(x, rand(80, W - 80), intensity);
        }
        autoTimer = rand(spawnRate * 40, spawnRate * 80);
      } else autoTimer--;
    }

    // Draw loop
    function drawBackground() {
      // subtle gradient night sky
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, '#081028');
      g.addColorStop(1, '#0b1a2a');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);
      // faint stars
      for (let i = 0; i < 40; i++) {
        const px = (i * 123 + 45) % W;
        const py = (i * 47 + 77) % H * 0.6;
        ctx.fillStyle = 'rgba(255,255,255,' + (0.02 + (i % 4) * 0.02) + ')';
        ctx.fillRect(px, py, 1, 1);
      }
    }

    function frame() {
      // fade canvas slightly to create trails
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(6,10,18,0.28)';
      ctx.fillRect(0, 0, W, H);

      ctx.globalCompositeOperation = 'lighter';
      // rockets update/draw
      for (let i = rockets.length - 1; i >= 0; i--) {
        rockets[i].update(i);
        rockets[i].draw();
      }
      // particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(i);
        particles[i].draw();
      }
      // crackers update
      for (let i = crackers.length - 1; i >= 0; i--) {
        crackers[i].update(i);
      }

      // periodically spawn auto rockets based on intensity
      const intensity = parseInt(document.getElementById('intensity').value, 10);
      spawnAuto(intensity);

      requestAnimationFrame(frame);
    }

    // Clear sparks
    document.getElementById('clearBtn').addEventListener('click', () => {
      rockets.length = 0; particles.length = 0; crackers.length = 0;
      // clear canvas
      ctx.clearRect(0, 0, W, H);
      drawBackground();
    });

    // Click / touch to launch a big rocket + small cluster
    function pushRocketAt(x, y) {
      // launch from bottom towards click
      launchRocket(x, x, Math.max(1, parseInt(document.getElementById('intensity').value, 10)));
      // small immediate cracker burst near where clicked (simulating handheld cracker)
      crackers.push(new Cracker(x));
    }

    canvas.addEventListener('pointerdown', (e) => {
      // resume audio context on user gesture (Chrome requires)
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      pushRocketAt(x, e.clientY - rect.top);
    });

    // keyboard shortcuts: space -> huge barrage
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        for (let i = 0; i < 8; i++) {
          launchRocket(rand(40, W - 40));
        }
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        boomSound(0.5, 1.6);
      }
    });

    // Small initial welcome fireworks
    function initialShow() {
      for (let i = 0; i < 6; i++) {
        setTimeout(() => launchRocket(rand(80, W - 80)), i * 350);
      }
    }

    // initial background draw
    drawBackground();
    initialShow();
    frame();

    // minor decorative header canvas fade on top
    // ensure resizing triggers background redraw
    window.addEventListener('resize', () => drawBackground());

    // Accessibility: if user cannot see canvas, fallback text is in DOM.

  })();
  </script>
</body>
</html>
